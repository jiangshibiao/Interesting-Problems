## 趣题摘记

> 记录遇到的有趣的题。主要是数学和算法问题。

## 一个简单游走问题

- 初始时你在数轴的位置 $0$ 处。每单位时间你能向左或者向右走一格。
- 问第一次走到 $1$ 的期望步数。
- 解法一：
    + 设 $f_i$ 表示正好向右走了 $i$ 步的期望。得 $f_i=\frac{1}{2}(f_{i-1}+f_{i+1})+1$ 且 $f_0=0$，联立化简后得 $f_i = 2f_{i-1}-f_{i-2}-2(i \geq 2)$。继续化简得 $f_i=(3i-4)f_1-(i-1)i$。
    + 我们要求的是 $f_1$。假设 $f_1=x$，则 $f_n=(3n-4)x-(n-1)n$，当 $n \rightarrow +\infty$ 时 $f_n \rightarrow -\infty$，显然矛盾。所以 $f_1=+\infty$
- 上述做法太麻烦了。解法二：
    + 设 $f_1$ 表示正好向右走了一步的期望。注意期望是有可加性的，所以$f_1=\frac{1}{2}(0+2f_1)+1$，化简得 $f_1=f_1+1$。显然 $f_1=+\infty$。

## 一个概率构造问题

- 一个函数 $f()$ 会以 $p$ 的概率返回 $1$，以 $1-p$ 的概率返回0。
- 要构造一个函数 $g()$，以正好 $0.5$ 的概率返回 $0$ 和 $1$。
- 注意：$p$ 是一个固定但是未知的概率。
- 解法一：
    - 连续调用两次 $f()$，显然返回 $01$ 和 $10$ 的概率相同，我们可以根据这个来决定 $g()$ 的返回，如果返回值相同，就继续这么操作。显然，当 $p \rightarrow 0/1$ 时，这个的期望步数趋于无穷大。
- 解法二（改进）：
    - 我们可以设计算法使期望步数进一步下降。
    - 对于询问序列的一个前缀长度 $n$，一旦 $C_n^m$ 是偶数（$m$ 是返回的 $1$ 的个数），其实我们就能立即结束并得到返回值（总能分成两半）。
    - 如何决定返回什么呢？每次看当前01序列和它的回文哪个字典序小，一样就递归一半，复杂度是 $O(N)$ 的。
    -  [知乎](https://www.zhihu.com/question/304075115) 上有更详细讨论。

## 一个概率构造和计算问题

- 有 $100$ 个人被编号为 $1 \sim 100$，对应他们编号的 $100$ 个号码牌被打乱顺序放在了$100$ 个抽屉里。每个人可以打开至多半数的抽屉，并从中找出对应自己编号的号码牌。只有所有人都找到了自己的号码牌，任务才算成功（所有人会依次独立地操作，彼此不能交流，操作完后所有抽屉都会复原）。**假设抽屉的各种放置状态出现的概率均等**，设计一种固定的策略，所有人都成功的概率尽可能的大。
- 成功的概率比直觉上要高很多。
- 策略：**首先打开自己号码的抽屉，如果没中，继续打开抽屉里号码牌对应的抽屉……重复50次。**。
- 分析：
    + 显然，所有人都能找到自己，当且仅当所有圆环的长度不超过 $50$。
    + 下面就是要计算，对于一个随机排列，置换环长度全都不超过 $50$ 的概率是多少。
    + 容斥。从 $100$ 个数中选出 $m(> 50)$ 个数构成大环（剩下的随便排）的方案数是：$C_{100}^m \cdot (m-1)! \cdot (100-m)!$
    + 所以最终答案为 $P=1-\sum \limits_{m=51}^{100} \frac{1}{m}$。且当 $n \rightarrow \infty$ 时，$P \rightarrow 1-\ln{2}$

## BP 算法

- 描述
    + 已知联合分布函数 $F(x_1,x_2,...x_n)$ （可以设 $x_i=0,1$ 来简化思考），求每个 $x_i$ 的边缘分布函数。
    + 一般认为联合分布函数比较“稀疏”，可以用一张无向图（因子图, factor graph）来描述（点是变量，边是两个变量之间的条件概率函数，设为 $\Phi_{i,j}$）。
    + 例子：一个五个变量的因子图以及信息的传递。
    ![](0801-1.png)
- 转化
    + 一般认为，可以从物理角度去解析某个概率分布的构型。具体地，设上述图的能量为：
        ![](0801-2.png)
    + 这样，某构型 $E=\{x_1,x_2...x_n\}$ 出现的概率是 $\frac{1}{normalize} e^{-E}$
    + 不是很懂实际的物理意义，我将这部分转化理解为：将求边缘分布函数 $f(p)$ 的累乘通过取 $\log$ 转化为累加。
    + 取完对数后，比如我们要求的 $P(x_1)$ 就可以表示为：
         ![](0801-3.png)
- 迭代过程
    + 迭代其实就是把上述式子不断累加求出来的过程。
    + 定义点 $i \rightarrow j$ 的 `message` 为：
        ![](0801-4.png)
    + 很显然，上述式子是一个迭代的过程。且易得 $P(x_i) = \prod \limits_{j \in N(i)} m_{ji}(x_i)$

## 一个简单抛硬币问题

- 抛一枚质地均匀的硬币。问期望多少次抛出连续两个向上。
- 解法：这一类期望问题都不宜直接在序列上计算，可以直接根据概率的意义计算。设 $f_i$ 表示连续抛出 $i$ 个向上的期望抛硬币次数。显然 $f_1=2,f_i=f_{i-1}+1+\frac{1}{2}f_i$，化简得 $f_i=2f_{i-1}+2$，原问题里 $f_2=6$。

## 一道CCPC2019的题

- 比完后再更

## 一道2018北大集训的题

- 描述
    + 已知 $N$ 个数中恰好有 $k$ 个不同的数字出现了奇数次。
    + 只能扫一遍，要求出这 $k$ 个数。$N$ 很大，$k \leq 10$，内存很小。

- 以前只会做 $k \leq 2$ 的版本……

- 一个子问题
    + 对于一个数字集合 $S$，如何判断是否只有一个数字出现了奇数次（还要支持动态加数字）？
    + 给出一个概率做法：
        - 取一个模数 $P$（如 $998244353$）以及模域下的一个常数 $c$。
        - 对于每一个进来的数 $x$，取一个映射 $f(x)=y$，只维护该集合 $y$ 的异或和 $xor_y$。其中 $f(x)=rP+c$，$r$ 每次都是随机的。
        - 如果只有一个数字出现了奇数次，必然有 $xor_y \mod P=c$；反之，我们**可以**认为不成立。
        - 不放心的话可以多取几个模数。如果还要还原方案，再维护一下 $x$ 的异或和即可。
    + 注意到，**这个做法还支持快速子集合并**。

- 做法
    + 维护 $m$ 个数字集合（比如取 $m=20$），彼此独立。
    + 每次来了一个数字 $x$ 后，依次枚举集合。每个集合都有 $\frac{1}{2}$ 的概率接受这个数字。
    + $N$ 个数字插入完成后，用 $2^m$ 枚举数字集的子集。对于一个子集 $S$，用上述做法合并对应数字集，看看总集合里**是否只有一个数字 $t$ 出现了奇数次**。如果是，他必然是这 $k$ 个答案中的一个。
    + 枚举完所有子集后，汇总去重即为答案。**这是个概率做法，可能会漏解**（但是准确率其实很高）。

+ 准确性高的直观分析
    + 假设 **子问题的判定是绝对正确的**（多取几个模数即可）。
    + 考虑一个行数为 $k$，列数为 $m$ 的01矩阵。$0$ 和 $1$ 表示这个答案 $t$ 在这个数字集里是否出现奇数次。
    + 如果能枚举到所有 $k$ 个答案，说明对于每一行，都存在至少一个列集合 $S$，满足列集合异或后是这一行的 `one hot`。进一步能推导出，这个矩阵满秩（在在异或空间下考虑问题）；反过来，如果该矩阵满秩，列向量就能组合出所有 $2^k$ 列向量，当然也能拼成 `one hot`。所以说，**能搜到所有解和矩阵满秩是充要的**。
    + 由之前的随机做法，可以认为矩阵的每个元素出现 $0$ 和 $1$ 的概率均等。现在我们来估计出错（不满秩）的概率：对于前 $n-1$ 行，随便取 $01$ 的状态；如果第 $n$ 行和它们 $2^{n-1}$ 子集异或和都不同，就可以满秩。所以不满秩的概率约为 $\frac{1}{2^m} \cdot 2^{n-1}$ 。